<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AlgoTrader: Professional Multi-Asset Simulated Market (Margin)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;600;800&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            /* CRITICAL for full screen height: body must take full viewport height */
            min-height: 100vh; 
        }
        
        /* Responsive Layout Adjustments for full screen width/height */
        .main-container {
            width: 100%; 
            padding: 0; 
            max-width: 1200px; 
            /* Added h-full to use all available vertical space */
            height: 100%; 
        }

        /* Content Wrapper: Ensure it uses flex to manage vertical space for its children */
        .content-wrapper {
            display: flex;
            flex-direction: column;
            flex-grow: 1; /* Allows the wrapper to fill vertical space inside the main-container */
            height: 100%; 
            min-height: 0; /* Allows the flex-grow chart to shrink below its natural height if needed */
        }
        
        /* Chart Area Container: Use flex-grow to make it consume available space */
        .chart-area-row {
            display: flex;
            flex-grow: 1; /* Critical: This row will now expand vertically */
            /* Lowered minimum height to allow controls to fit on shorter screens */
            min-height: 250px; 
            margin-bottom: 1rem; /* Reduced margin to save space */
        }

        /* Price Axis and Chart Container also need to flex-grow inside the row */
        #chart-container {
            flex-grow: 1;
        }

        /* Ensure content inside the main container doesn't get too wide on very large screens for readability */
        @media (min-width: 1024px) {
            .main-container {
                max-width: 1200px; /* Max width for content area */
            }
        }

        /* Style for the price axis container */
        #price-axis {
            color: #9ca3af;
        }
        /* Style for the axis labels (now handled via absolute positioning in JS/Tailwind) */
        .axis-label {
            text-align: right; 
            width: 100%; /* Ensure label takes full width of the axis column */
            line-height: 1; /* Prevent line height from affecting vertical position */
        }
    </style>

    <script>
        // --- CONFIGURATION ---
        const INITIAL_BANKROLL = 100000.00; 
        const INITIAL_MARGIN_RATE = 0.05; // 5% Initial Margin of the gross contract value
        
        /**
         * Rounds a floating point value to the nearest specified tick size.
         * @param {number} value - The raw price value.
         * @param {number} tick - The minimum price increment (e.g., 0.25, 0.01).
         * @returns {number} The rounded value.
         */
        const roundToTick = (value, tick) => {
            if (tick <= 0) return value;
            // Use Math.round(x / y) * y logic to handle precision
            const rounded = Math.round(value / tick) * tick;
            // Fix potential floating point errors by rounding the final result to the correct decimal places
            // We use toFixed(4) internally for calculations to maintain precision before presentation
            const decimals = tick.toString().split('.')[1] ? tick.toString().split('.')[1].length : 0;
            return parseFloat(rounded.toFixed(Math.max(4, decimals + 2))); 
        };
        
        // --- Asset Definitions and State ---

        // usdGrossValuePerContract is used for margin calculation for Forex contracts
        // Commodity contracts use the standard multiplier/unitFactor calculation
        const ASSETS = {
            // --- FOREX CONTRACTS (JPY Quoted) ---
            'USDJPY': { 
                name: 'USD/JPY (FX)', 
                startPrice: 150.00, 
                volatility: 0.15, 
                unit: 'JPY',
                type: 'FOREX_JPY_QUOTE',
                multiplier: 100000, // 100k USD base equivalent
                usdGrossValuePerContract: 100000, 
                tickSize: 0.01 
            },
            'AUDJPY': { 
                name: 'AUD/JPY (FX)', 
                startPrice: 98.00, 
                volatility: 0.18, 
                unit: 'JPY',
                type: 'FOREX_JPY_QUOTE',
                multiplier: 100000, // 100k AUD base equivalent
                usdGrossValuePerContract: 65000, 
                tickSize: 0.01
            },
            'CADJPY': { 
                name: 'CAD/JPY (FX)', 
                startPrice: 110.00, 
                volatility: 0.12, 
                unit: 'JPY',
                type: 'FOREX_JPY_QUOTE',
                multiplier: 100000, // 100k CAD base equivalent
                usdGrossValuePerContract: 72000, 
                tickSize: 0.01
            },
            
            // --- ENERGY ---
            'CL': { 
                name: 'Crude Oil (CL)', 
                startPrice: 80.00, 
                volatility: 0.8, 
                unit: 'USD/bbl',
                multiplier: 1000, // 1,000 barrels per contract
                unitFactor: 1, // Price is already in USD
                tickSize: 0.01 // Standard $0.01 per barrel increment
            },
            
            // --- SOFT COMMODITIES ---
            'KC': { 
                name: 'Arabica Coffee (KC)', 
                startPrice: 200.00, 
                volatility: 4.0, 
                unit: 'USC/lb',
                multiplier: 37500, // 37,500 pounds per contract
                unitFactor: 0.01, // Price is in Cents, conversion factor to USD
                tickSize: 0.05 // Standard 5 cent (USC) increment
            },
            'SB': { 
                name: 'Sugar #11 (SB)', 
                startPrice: 25.00, 
                volatility: 0.5, 
                unit: 'USC/lb',
                multiplier: 112000, // 112,000 pounds per contract
                unitFactor: 0.01, // Price is in Cents, conversion factor to USD
                tickSize: 0.01
            },

            // --- AGRICULTURAL (Grains & Oils) ---
            'CORN': { 
                name: 'Corn (ZC)', 
                startPrice: 450.00, 
                volatility: 1.5, 
                unit: 'USC/bu',
                multiplier: 5000, // 5,000 bushels per contract
                unitFactor: 0.01, 
                tickSize: 0.25 // Standard 0.25 cent increment
            },
            'WHEAT': { 
                name: 'Wheat (ZW)', 
                startPrice: 580.00, 
                volatility: 2.0, 
                unit: 'USC/bu',
                multiplier: 5000,
                unitFactor: 0.01,
                tickSize: 0.25 
            },
            'SOYBEANS': { 
                name: 'Soybeans (ZS)', 
                startPrice: 1200.00, 
                volatility: 3.0, 
                unit: 'USC/bu',
                multiplier: 5000,
                unitFactor: 0.01,
                tickSize: 0.25 
            },
            'SOYMEAL': { 
                name: 'Soybean Meal (ZM)', 
                startPrice: 400.00, 
                volatility: 2.5, 
                unit: 'USD/st',
                multiplier: 100, // 100 short tons per contract
                unitFactor: 1, 
                tickSize: 0.10 
            },
            'SOYOIL': { 
                name: 'Soybean Oil (ZL)', 
                startPrice: 45.00, 
                volatility: 0.5, 
                unit: 'USC/lb',
                multiplier: 60000, // 60,000 lbs per contract
                unitFactor: 0.01, 
                tickSize: 0.01 
            }
        };
        
        // Trading State 
        let gameState = {
            bankroll: INITIAL_BANKROLL, 
            positionSize: 0, 
            avgEntryPrice: 0.00,
            currentAssetId: 'USDJPY', 
            lastUpdateTime: Date.now()
        };

        // Market Simulation State 
        let currentPrice = ASSETS['USDJPY'].startPrice;
        let priceHistory = [];
        let priceHistoryLength = 50;
        let momentum = 0.0;
        let momentumTicks = 0;
        let maxMomentumTicks = 30;

        // --- UI Element References ---
        let bankrollEl, equityEl, positionSizeEl, entryPriceEl, unrealizedPnLEl;
        let priceEl, assetSelectorEl, unitLabelEl, requiredMarginEl, tickSizeEl;
        let canvas, ctx;
        let buyBtn, sellBtn, closeBtn, quantityInput, statusMessageEl, priceAxisEl;

        // --- LOCAL STORAGE MANAGEMENT ---

        const saveGameState = () => {
            localStorage.setItem('traderGameState', JSON.stringify(gameState));
            updateUI();
        };

        const loadGameState = () => {
            const storedState = localStorage.getItem('traderGameState');
            if (storedState) {
                const loadedState = JSON.parse(storedState);
                gameState = {
                    ...gameState, 
                    ...loadedState, 
                };
            } else {
                gameState.bankroll = INITIAL_BANKROLL;
            }
            
            // Initialize market simulation for the current asset
            switchAsset(gameState.currentAssetId, false);
        };

        const resetGameState = () => {
            gameState.bankroll = INITIAL_BANKROLL;
            gameState.positionSize = 0;
            gameState.avgEntryPrice = 0.00;
            gameState.currentAssetId = 'USDJPY';
            localStorage.removeItem('traderGameState');
            switchAsset('USDJPY', false);
            statusMessageEl.textContent = "Simulation completely reset. Starting fresh with USD/JPY.";
        };
        
        // --- ASSET SWITCHING ---

        const switchAsset = (assetId, resetPosition = true) => {
            if (!ASSETS[assetId]) return;

            // Realize PnL and close position if switching markets while holding a position
            if (resetPosition && gameState.positionSize !== 0) {
                 const currentAsset = ASSETS[gameState.currentAssetId];
                 const realizedPnL = calculatePnL(currentPrice, gameState.avgEntryPrice, gameState.positionSize, currentAsset);
                 
                 // BANKROLL UPDATE ONLY ON CLOSE
                 gameState.bankroll += realizedPnL;
                 
                 statusMessageEl.textContent = `Position of ${gameState.positionSize} contracts in ${currentAsset.name} closed before switching. Realized PnL: $${realizedPnL.toFixed(2)}.`;
                 gameState.positionSize = 0;
                 gameState.avgEntryPrice = 0.00;
            } else if (resetPosition && assetId !== gameState.currentAssetId) {
                 statusMessageEl.textContent = `Switched to ${ASSETS[assetId].name}.`;
            }

            gameState.currentAssetId = assetId;
            const asset = ASSETS[assetId];
            
            // Reset market simulation state
            currentPrice = asset.startPrice;
            priceHistory = [{ price: currentPrice, timestamp: Date.now() }];
            momentum = 0.0;
            momentumTicks = 0;

            // Update UI elements
            assetSelectorEl.value = assetId;
            unitLabelEl.textContent = asset.unit;
            
            // Determine price display precision
            const priceDecimals = asset.tickSize.toString().includes('.') ? asset.tickSize.toString().split('.')[1].length : 0;
            
            // Format tick size for display
            tickSizeEl.textContent = `${asset.tickSize.toFixed(priceDecimals)} ${asset.unit.split('/')[0]}`;

            saveGameState();
            updateUI();
        };


        // --- PRICE SIMULATION LOGIC ---

        const generateNextPrice = () => {
            const asset = ASSETS[gameState.currentAssetId];
            const volatility = asset.volatility;
            const tick = asset.tickSize; 

            if (momentumTicks <= 0) {
                momentum = (Math.random() < 0.5 ? -1 : 1) * (Math.random() * volatility * 0.2);
                momentumTicks = Math.floor(Math.random() * maxMomentumTicks) + 10;
            } else {
                momentumTicks--;
            }

            const randomNoise = (Math.random() - 0.5) * volatility;

            let rawPrice = currentPrice + randomNoise + momentum;
            currentPrice = roundToTick(rawPrice, tick);
            
            if (currentPrice < tick) currentPrice = tick;

            priceHistory.push({ price: currentPrice, timestamp: Date.now() });
            while (priceHistory.length > priceHistoryLength) {
                priceHistory.shift();
            }
        };

        const gameLoop = () => {
            generateNextPrice();
            
            if (priceHistory.length % 5 === 0) {
                 saveGameState();
            } else {
                 updateUI(); 
            }

            setTimeout(gameLoop, 3000); 
        };


        // --- UTILITY: Calculate Gross Value, Margin, and PnL ---

        /** Calculates the total gross USD value of a position in contracts. */
        const calculateGrossValue = (price, quantity, asset) => {
            if (asset.type && asset.type.startsWith('FOREX')) {
                // Forex: Use the fixed Gross Contract Value (GCV) for margin purposes in a USD account
                return asset.usdGrossValuePerContract * quantity;
            } else {
                // Commodity: GCV is calculated based on price: Price * Contracts * Units/Contract * $/Unit
                return price * quantity * asset.multiplier * asset.unitFactor;
            }
        };

        /** Calculates the required initial margin for a quantity of contracts. */
        const calculateRequiredMargin = (price, quantity, asset) => {
            return calculateGrossValue(price, quantity, asset) * INITIAL_MARGIN_RATE;
        }

        /** Calculates the PnL in USD for a given size based on current vs. entry price. */
        const calculatePnL = (currentPrice, entryPrice, positionSize, asset) => {
             if (positionSize === 0) return 0;
             
             // Price difference in QUOTED UNITS
             const priceDifference = currentPrice - entryPrice;
             const absPositionSize = Math.abs(positionSize);
             
             if (asset.type === 'FOREX_JPY_QUOTE') {
                 // JPY Quoted Forex PnL: (Exit Price - Entry Price) * Units/Contract * Contracts
                 // PnL is in JPY, must convert to USD by dividing by the current rate (price).
                 
                 // PnL in JPY
                 const pnlInQuoteCurrency = priceDifference * absPositionSize * asset.multiplier; 
                 
                 // Convert JPY PnL to USD PnL using the current rate (price)
                 let pnl = pnlInQuoteCurrency / currentPrice; 
                 
                 // Reverse PnL sign for short positions
                 if (positionSize < 0) {
                      pnl = -pnl; 
                 }
                 
                 return pnl;
             }
             
             // Commodity PnL (Standard Calculation)
             const pnlBase = priceDifference * absPositionSize * asset.multiplier * asset.unitFactor;
             
             if (positionSize > 0) {
                 return pnlBase;
             } else {
                 return -pnlBase;
             }
        };


        // --- TRADING ACTIONS ---

        const executeTrade = (action) => {
            const asset = ASSETS[gameState.currentAssetId];
            const quantity = parseInt(quantityInput.value) || 1;
            
            if (quantity <= 0) {
                statusMessageEl.textContent = "Enter a valid quantity (contracts).";
                return;
            }
            
            let newBankroll = gameState.bankroll; // Start with current bankroll
            let newPositionSize = gameState.positionSize;
            let newAvgEntryPrice = gameState.avgEntryPrice;
            let realizedPnL = 0; // Tracks PnL realized in this trade
            
            statusMessageEl.textContent = ""; 
            
            try {
                if (action === 'BUY' || action === 'SELL') {
                    
                    const tradeSign = action === 'BUY' ? 1 : -1;
                    const oldPositionSize = gameState.positionSize;
                    const newTotalSize = oldPositionSize + (quantity * tradeSign);
                    const finalPositionSize = Math.abs(newTotalSize);
                    
                    // --- Margin Check: Required margin for the FINAL absolute position size ---
                    // Use currentPrice for margin check as it reflects the "cost" of the new/total position
                    const totalMarginAfterTrade = calculateRequiredMargin(currentPrice, finalPositionSize, asset);

                    if (gameState.bankroll < totalMarginAfterTrade) {
                         throw new Error(`Insufficient margin. Need $${formatNumberWithCommas(totalMarginAfterTrade.toFixed(2))} USD available in cash to cover total position margin.`);
                    }

                    // --- Realization Logic (Partial Close) ---
                    const isPartialClose = (
                        (oldPositionSize > 0 && newTotalSize >= 0 && newTotalSize < oldPositionSize) || // Selling part of a LONG (e.g., +5 -> +3)
                        (oldPositionSize < 0 && newTotalSize <= 0 && newTotalSize > oldPositionSize)    // Buying part of a SHORT (e.g., -5 -> -3)
                    );
                    
                    if (isPartialClose) {
                        // FIX: When a partial close occurs, the number of contracts closed is exactly the quantity traded.
                        const contractsClosed = quantity; 
                        
                        // PnL Size: This must be the size of the position being closed, using the original position's sign
                        // to ensure the PnL calculation reflects the correct (Exit - Entry) relationship.
                        const pnlSizeToRealize = Math.sign(oldPositionSize) * contractsClosed;
                        
                        // Calculate realized PnL on the closed portion
                        realizedPnL = calculatePnL(currentPrice, gameState.avgEntryPrice, pnlSizeToRealize, asset);
                        
                        // Realize PnL into the bankroll
                        newBankroll += realizedPnL;
                        
                        // Update status message with realization detail
                        const formattedPnL = (realizedPnL >= 0 ? '+' : '') + formatNumberWithCommas(realizedPnL.toFixed(2));
                        const side = oldPositionSize > 0 ? 'LONG' : 'SHORT';
                        statusMessageEl.textContent = `Partial close (${side}). Realized PnL on ${contractsClosed} contracts: $${formattedPnL}. `;
                    }

                    // --- VWAP/New Position Logic ---
                    
                    let vwapNeeded = false;
                    
                    if (Math.sign(newTotalSize) !== Math.sign(oldPositionSize)) {
                        // Case: Position flip or starting a new position from zero
                        vwapNeeded = true;
                    } else if (Math.abs(newTotalSize) > Math.abs(oldPositionSize)) {
                        // Case: Increasing position size (adding to long or short)
                        vwapNeeded = true;
                    }
                    
                    if (vwapNeeded) {
                        const contractsToVWAP = Math.abs(newTotalSize); 
                        
                        if (oldPositionSize === 0 || Math.abs(newTotalSize) !== contractsToVWAP) {
                            // Starting a new position or flipping to opposite side (set new entry price)
                            newAvgEntryPrice = currentPrice;
                        } else {
                            // Increasing position (VWAP)
                            // We average the ENTRY PRICES, not the GCV, for margin/PnL calculation
                            newAvgEntryPrice = ((newAvgEntryPrice * Math.abs(oldPositionSize)) + (currentPrice * quantity)) / Math.abs(newTotalSize);
                        }
                        
                        // If a flip happened, the new entry price is the current price
                        if (Math.sign(oldPositionSize) !== Math.sign(newTotalSize) && oldPositionSize !== 0) {
                            newAvgEntryPrice = currentPrice;
                        }
                    }
                    
                    // Final position update
                    newPositionSize = newTotalSize;
                    
                    // Append status message for the action executed
                    let tradeActionMsg = statusMessageEl.textContent;
                    if (action === 'BUY') {
                         tradeActionMsg += `Bought ${quantity} contracts at ${currentPrice.toFixed(2)}.`;
                    } else {
                         tradeActionMsg += `Sold ${quantity} contracts at ${currentPrice.toFixed(2)}.`;
                    }
                    statusMessageEl.textContent = tradeActionMsg + ` New Margin Used: $${formatNumberWithCommas(totalMarginAfterTrade.toFixed(2))}.`;


                    // Final safety rounding of the new average entry price
                    if (newPositionSize === 0) {
                        newAvgEntryPrice = 0; // Reset entry price if position is flat
                    } else if (newAvgEntryPrice !== 0) {
                        newAvgEntryPrice = roundToTick(newAvgEntryPrice, asset.tickSize);
                    }

                } else if (action === 'CLOSE') {
                    if (newPositionSize === 0) {
                        throw new Error("No open position to close.");
                    }
                    
                    // 1. Calculate Realized PnL for the full closure
                    realizedPnL = calculatePnL(currentPrice, newAvgEntryPrice, newPositionSize, asset);
                    
                    // 2. UPDATE BANKROLL with realized PnL (Margin Model Rule)
                    newBankroll = gameState.bankroll + realizedPnL;
                    
                    // Reset position state
                    newPositionSize = 0;
                    newAvgEntryPrice = 0.00;
                    
                    const formattedPnL = (realizedPnL >= 0 ? '+' : '') + formatNumberWithCommas(realizedPnL.toFixed(2));

                    statusMessageEl.textContent = `Position fully closed. Realized PnL: $${formattedPnL}. New Bankroll: $${formatNumberWithCommas(newBankroll.toFixed(2))}.`;
                }
                
                // Update global state and save
                gameState.bankroll = newBankroll;
                gameState.positionSize = newPositionSize;
                gameState.avgEntryPrice = newAvgEntryPrice;
                saveGameState();

            } catch (e) {
                console.error("Trade failed:", e);
                statusMessageEl.textContent = `Trade failed: ${e.message}`;
            }
        };

        // --- UI RENDERING & UPDATES ---

        /** Utility function to format a number with commas and two decimals. */
        const formatNumberWithCommas = (n) => {
            // Handle negative sign correctly
            const sign = n < 0 ? '-' : '';
            const absoluteN = Math.abs(n).toFixed(2);
            // Add commas to the integer part
            const parts = absoluteN.split('.');
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
            return sign + parts.join('.');
        };

        const calculateCurrentPnL = () => {
             return calculatePnL(currentPrice, gameState.avgEntryPrice, gameState.positionSize, ASSETS[gameState.currentAssetId]);
        };

        const calculateTotalRequiredMargin = () => {
            if (gameState.positionSize === 0) return 0;
            const asset = ASSETS[gameState.currentAssetId];
            // Margin is calculated based on the entry price/GCV, not the current price, for stable requirement calculation.
            // Using avgEntryPrice is safer for consistent margin tracking
            return calculateRequiredMargin(gameState.avgEntryPrice, Math.abs(gameState.positionSize), asset);
        };

        const updateUI = () => {
            const pnl = calculateCurrentPnL();
            const equity = gameState.bankroll + pnl;
            const totalRequiredMargin = calculateTotalRequiredMargin();
            const asset = ASSETS[gameState.currentAssetId];

            // Formatters
            const formatCurrency = (n) => `$${formatNumberWithCommas(n)}`; 
            const formatPrice = (n) => {
                 // Determine price display precision
                const priceDecimals = asset.tickSize.toString().includes('.') ? asset.tickSize.toString().split('.')[1].length : 0;
                // Use max(2, priceDecimals) to ensure we always show at least 2 decimals (for USD, etc.)
                return n.toFixed(Math.max(2, priceDecimals)); 
            }
            const formatPnL = (n) => {
                const color = n >= 0 ? 'text-green-400' : 'text-red-400';
                // Apply $ symbol, sign, and commas
                const formatted = formatNumberWithCommas(n);
                // Remove the initial sign added by formatNumberWithCommas, and re-add a controlled sign with $
                const baseValue = formatted.startsWith('-') ? formatted.substring(1) : formatted;
                return `<span class="${color}">${n >= 0 ? '+$' : '-$'}${baseValue}</span>`;
            };

            if (!bankrollEl) return; 
            
            // Update Stats Panel
            // Bankroll, Equity, and Required Margin use formatCurrency
            bankrollEl.textContent = formatCurrency(gameState.bankroll);
            equityEl.innerHTML = formatCurrency(equity);
            positionSizeEl.textContent = gameState.positionSize;
            
            // Entry price uses the dynamic price formatter
            entryPriceEl.textContent = formatPrice(gameState.avgEntryPrice);
            
            // Unrealized PnL uses the new formatPnL
            unrealizedPnLEl.innerHTML = formatPnL(pnl);
            
            // Current price uses the dynamic price formatter
            priceEl.textContent = formatPrice(currentPrice);
            requiredMarginEl.textContent = formatCurrency(totalRequiredMargin);
            
            // Color the price based on movement
            const lastPrice = priceHistory.length > 1 ? priceHistory[priceHistory.length - 2].price : currentPrice;
            priceEl.classList.toggle('text-green-400', currentPrice > lastPrice);
            priceEl.classList.toggle('text-red-400', currentPrice < lastPrice);
            priceEl.classList.toggle('text-white', currentPrice === lastPrice);
            
            // Update Control States
            const quantity = parseInt(quantityInput.value) || 1;
            
            // Calculate the TOTAL margin for the final position size (using current price for GCV)
            const proposedPositionSize = Math.abs(gameState.positionSize) + quantity; // Simple worst-case calc
            const totalMarginRequired = calculateRequiredMargin(currentPrice, proposedPositionSize, asset);

            // Margin check: You need enough cash (Bankroll) to cover the total margin for the final position.
            buyBtn.disabled = gameState.bankroll < totalMarginRequired; 
            sellBtn.disabled = gameState.bankroll < totalMarginRequired;
            
            closeBtn.disabled = gameState.positionSize === 0;

            renderChart();
        };

        const renderChart = () => {
            if (priceHistory.length < 2 || !ctx) return;
            
            const asset = ASSETS[gameState.currentAssetId];
            // Determine price display precision
            const priceDecimals = asset.tickSize.toString().includes('.') ? asset.tickSize.toString().split('.')[1].length : 0;
            // Use max(2, priceDecimals) for display
            const displayDecimals = Math.max(2, priceDecimals);

            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);

            // --- Y-AXIS SCALE FIX ---
            const prices = priceHistory.map(p => p.price);
            
            // Create a list of all relevant prices to scale against
            const scalePrices = [...prices];
            if (gameState.positionSize !== 0 && gameState.avgEntryPrice > 0) {
                // Add the entry price to the list so the axis includes it
                scalePrices.push(gameState.avgEntryPrice);
            }

            // Calculate min/max from this combined list
            let minPrice = Math.min(...scalePrices);
            let maxPrice = Math.max(...scalePrices);

            // FIX 2: Increased buffer from 1% to 5% to prevent labels from being cut off.
            const bufferPercentage = 0.05; 
            let padding = (maxPrice - minPrice) * bufferPercentage; 
            
            if (padding === 0) {
                 // If range is flat (all prices are the same), force a buffer based on tick size
                 padding = asset.tickSize * 5; 
            }
            
            minPrice -= padding;
            maxPrice += padding;
            
            let priceRange = maxPrice - minPrice;
            
            // Ensure a minimum range if prices are flat, based on tick size
            const minRange = asset.tickSize * 10; // e.g., 10 ticks
            if (priceRange < minRange) {
                 const midPoint = (maxPrice + minPrice) / 2;
                 maxPrice = midPoint + (minRange / 2);
                 minPrice = midPoint - (minRange / 2);
                 priceRange = maxPrice - minPrice;
            }
            // --- END Y-AXIS FIX ---


            // --- 1. Draw Grid Lines (Y-Axis) ---
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.beginPath();
            const numGridLines = 4; // 5 points/labels
            for (let i = 0; i <= numGridLines; i++) {
                const y = height / numGridLines * i;
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
            }
            ctx.stroke();

            // --- 2. Draw Price Line ---
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#34d399'; 
            
            priceHistory.forEach((data, index) => {
                const x = index / (priceHistoryLength - 1) * width;
                const y = height - ((data.price - minPrice) / priceRange) * height;

                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();

            // --- 3. Draw Entry Price Line ---
            if (gameState.positionSize !== 0) {
                const entryY = height - ((gameState.avgEntryPrice - minPrice) / priceRange) * height;
                ctx.setLineDash([5, 5]); // Dashed line
                ctx.strokeStyle = '#facc15'; // Amber
                ctx.beginPath();
                ctx.moveTo(0, entryY);
                ctx.lineTo(width, entryY);
                ctx.stroke();
                ctx.setLineDash([]); // Reset dash
            }
            
            // --- 4. Draw Current Price Dot ---
            const lastPriceData = priceHistory[priceHistory.length - 1];
            const lastY = height - ((lastPriceData.price - minPrice) / priceRange) * height;
            
            const lastPrice = priceHistory.length > 1 ? priceHistory[priceHistory.length - 2].price : currentPrice;
            ctx.fillStyle = currentPrice > lastPrice ? '#10b981' : '#ef4444'; 
            
            ctx.beginPath();
            ctx.arc(width, lastY, 5, 0, Math.PI * 2);
            ctx.fill();

            // --- 5. Draw Price Axis Labels (Y-Axis) ---
            priceAxisEl.innerHTML = '';
            priceAxisEl.style.position = 'relative'; // Mandatory for absolute positioning of children

            const numLabels = 5; 
            const priceStep = priceRange / (numLabels - 1);

            for (let i = 0; i < numLabels; i++) {
                // Label calculation is based on maxPrice, moving downwards
                const priceLabelRaw = maxPrice - (priceStep * i);
                const priceLabel = roundToTick(priceLabelRaw, asset.tickSize);
                
                // Calculate the corresponding Y position on the canvas (0 = top, height = bottom)
                // The canvas is divided into 4 segments (0, 1, 2, 3, 4) for 5 lines
                const y = height / (numLabels - 1) * i; 

                const labelEl = document.createElement('div');
                // Use Tailwind classes for positioning: absolute, anchored to the right edge, padding, color
                labelEl.className = 'axis-label absolute right-0 pr-1 text-gray-400';
                
                // Position the label element vertically centered on the line (y-50%)
                labelEl.style.top = `${y}px`;
                labelEl.style.transform = 'translateY(-50%)'; 
                
                // Show dynamic decimal places for price display
                const displayDecimals = Math.max(2, asset.tickSize.toString().includes('.') ? asset.tickSize.toString().split('.')[1].length : 0);
                labelEl.textContent = priceLabel.toFixed(displayDecimals); 
                
                // Highlight the label if it's very close to the entry price
                if (gameState.positionSize !== 0 && Math.abs(priceLabel - gameState.avgEntryPrice) < (priceStep * 0.1)) {
                    labelEl.classList.add('text-amber-400', 'font-bold');
                }

                priceAxisEl.appendChild(labelEl);
            }
        };
        
        // This function resizes the canvas to match its container when the window size changes
        const handleResize = () => {
            if (canvas && document.getElementById('chart-container')) {
                const chartContainer = document.getElementById('chart-container');
                // The canvas width and height are set to the *current* size of the container,
                // which is now dynamically sized by CSS/Tailwind flex properties.
                canvas.width = chartContainer.offsetWidth; 
                canvas.height = chartContainer.offsetHeight; 
                renderChart();
            }
        };


        // --- Event Listeners and Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            // Assign references 
            bankrollEl = document.getElementById('bankroll');
            equityEl = document.getElementById('equity');
            positionSizeEl = document.getElementById('position-size');
            entryPriceEl = document.getElementById('entry-price');
            unrealizedPnLEl = document.getElementById('unrealized-pnl');
            priceEl = document.getElementById('current-price');
            assetSelectorEl = document.getElementById('asset-selector');
            unitLabelEl = document.getElementById('unit-label');
            requiredMarginEl = document.getElementById('required-margin');
            tickSizeEl = document.getElementById('tick-size');
            canvas = document.getElementById('price-chart');
            buyBtn = document.getElementById('buy-btn');
            sellBtn = document.getElementById('sell-btn');
            closeBtn = document.getElementById('close-btn');
            quantityInput = document.getElementById('quantity-input');
            statusMessageEl = document.getElementById('status-message');
            priceAxisEl = document.getElementById('price-axis');
            const resetBtn = document.getElementById('reset-btn');

            if (canvas) {
                ctx = canvas.getContext('2d');
                // Initial canvas size
                handleResize(); 
            } else {
                 console.error("Canvas element not found!");
                 return; 
            }
            
            // Attach resize listener to ensure responsiveness
            window.addEventListener('resize', handleResize);


            // Populate Asset Selector
            Object.keys(ASSETS).forEach(id => {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = ASSETS[id].name;
                assetSelectorEl.appendChild(option);
            });

            // Event Listeners
            buyBtn.addEventListener('click', () => executeTrade('BUY'));
            sellBtn.addEventListener('click', () => executeTrade('SELL'));
            closeBtn.addEventListener('click', () => executeTrade('CLOSE'));
            resetBtn.addEventListener('click', () => resetGameState());
            assetSelectorEl.addEventListener('change', (e) => switchAsset(e.target.value, true));

            // Initial setup
            loadGameState();
            
            quantityInput.value = 1;
            statusMessageEl.textContent = `Market loaded: ${ASSETS[gameState.currentAssetId].name}. Trading on 5% Margin.`;

            // Start the game loop
            gameLoop();
        });
    </script>
</head>
<!-- Body now uses min-h-screen and flex flex-col to ensure the content wrapper fills the space -->
<body class="bg-gray-900 text-white min-h-screen p-4 flex flex-col items-center">
    <!-- Main container updated to flex-grow and h-full -->
    <div class="main-container flex flex-col h-full flex-grow items-center w-full">
        <!-- Content Wrapper is now a flex column that takes up vertical space -->
        <!-- *** Vertical Space Optimized: Changed p-6 to p-4 and space-y-4 to space-y-3 *** -->
        <div class="content-wrapper bg-gray-800 rounded-xl shadow-2xl p-4 w-full space-y-3 flex flex-col h-full">
            <header class="text-center border-b border-gray-700 pb-3 flex-shrink-0">
                <h1 class="text-4xl font-extrabold text-teal-400 tracking-tight font-serif">AlgoTrader <span class="text-xl font-light text-gray-400">v1.3 - Precision Margin Trading Simulator</span></h1>
                <p class="text-sm text-gray-500 mt-1">Simulate margin trading with real-time PnL and risk tracking across multiple asset classes.</p>
            </header>
            
            <!-- Asset Selector / Current Price -->
            <div class="flex flex-col sm:flex-row justify-between items-center bg-gray-700 p-3 rounded-lg shadow-md flex-shrink-0">
                <div class="flex items-center space-x-3 w-full sm:w-1/2">
                    <label for="asset-selector" class="text-lg font-light text-gray-300">Market:</label>
                    <select id="asset-selector" class="flex-grow bg-gray-600 border border-gray-500 rounded-md p-2 text-white focus:outline-none focus:border-teal-400">
                        <!-- Options populated by JS -->
                    </select>
                </div>
                
                <div class="flex items-center space-x-3 mt-3 sm:mt-0 sm:w-1/2 justify-end">
                    <span id="current-price" class="text-4xl font-extrabold text-white transition-colors duration-500">150.00</span>
                    <span id="unit-label" class="text-xl font-light text-gray-400">JPY</span>
                </div>
            </div>
            
            <!-- PnL & Equity Row -->
             <div class="flex flex-col sm:flex-row justify-between items-center bg-gray-700 p-3 rounded-lg shadow-md flex-shrink-0">
                <div class="text-center sm:text-left">
                    <span class="text-lg font-medium text-gray-300">Equity (Cash + PnL):</span>
                    <span id="equity" class="text-3xl font-bold text-green-400 block">$100,000.00</span>
                </div>
                <div class="text-center sm:text-right mt-3 sm:mt-0">
                    <span class="text-lg font-medium text-gray-300">Unrealized PnL:</span>
                    <span id="unrealized-pnl" class="text-3xl font-bold text-green-400 block">+$0.00</span>
                </div>
            </div>
            
            <!-- Status Message -->
            <div id="status-message" class="text-center text-sm font-semibold text-amber-400 flex-shrink-0">
                Initializing market data...
            </div>

            <!-- Chart Area: The key container set to FLEX-GROW -->
            <div class="chart-area-row flex space-x-2 flex-grow min-h-[250px]">
                <!-- Price Axis (Y-Axis) - Updated classes for absolute positioning control -->
                <div id="price-axis" class="h-full w-16 text-xs flex-shrink-0">
                    <!-- Labels dynamically inserted here (now using absolute positioning) -->
                </div>
                <!-- Canvas Container -->
                <div id="chart-container" class="flex-grow bg-gray-900 border border-gray-600 rounded-lg overflow-hidden relative">
                    <canvas id="price-chart" class="w-full h-full"></canvas>
                    <!-- Time Axis Overlay -->
                    <div class="absolute inset-0 flex items-end justify-between p-2 text-xs text-gray-400 pointer-events-none">
                        <span>Oldest</span>
                        <span>Latest</span>
                    </div>
                </div>
            </div>

            <!-- Portfolio Stats & Trade Controls (Grid Layout) -->
            <!-- *** Flex-shrink-0 added to ensure this entire section is prioritized to stay on screen *** -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 flex-shrink-0">
                
                <!-- Portfolio Stats -->
                <div class="md:col-span-2 space-y-3">
                    <h2 class="text-xl font-bold text-teal-400 border-b border-gray-700 pb-1">Portfolio Overview</h2>
                    <div class="grid grid-cols-2 gap-3 text-sm font-medium">
                        <div class="bg-gray-700 p-3 rounded-lg flex justify-between">
                            <span class="text-gray-400">Bankroll (Cash):</span>
                            <span id="bankroll" class="text-white font-bold">$100,000.00</span>
                        </div>
                         <div class="bg-gray-700 p-3 rounded-lg flex justify-between">
                            <span class="text-gray-400">Min. Tick Size:</span>
                            <span id="tick-size" class="text-white font-bold">0.00 JPY</span>
                        </div>
                        <div class="bg-gray-700 p-3 rounded-lg flex justify-between">
                            <span class="text-gray-400">Position Size (Contracts):</span>
                            <span id="position-size" class="text-white font-bold">0</span>
                        </div>
                        <div class="bg-gray-700 p-3 rounded-lg flex justify-between">
                            <span class="text-gray-400">Required Margin (Total):</span>
                            <span id="required-margin" class="text-white font-bold">$0.00</span>
                        </div>
                        <div class="bg-gray-700 p-3 rounded-lg flex justify-between col-span-2">
                            <span class="text-gray-400">Avg. Entry Price:</span>
                            <span id="entry-price" class="text-white font-bold">0.00</span>
                        </div>
                    </div>
                </div>

                <!-- Trade Controls -->
                <div class="md:col-span-1 space-y-3">
                    <h2 class="text-xl font-bold text-teal-400 border-b border-gray-700 pb-1">Trade Actions</h2>
                    
                    <!-- Quantity Input -->
                    <div class="flex items-center space-x-2 bg-gray-700 p-2 rounded-lg">
                        <label for="quantity-input" class="text-gray-400 font-medium text-sm">Quantity:</label>
                        <input type="number" id="quantity-input" min="1" value="1" class="w-full bg-gray-600 border border-gray-500 rounded-md px-2 py-1 text-right text-white focus:outline-none focus:border-teal-400" />
                    </div>
                    
                    <!-- Action Buttons -->
                    <div class="space-y-2">
                        <!-- Buy and Sell buttons are side-by-side using flex -->
                        <div class="flex space-x-2">
                            <button id="buy-btn" class="flex-1 py-2 rounded-lg font-bold text-lg bg-green-600 hover:bg-green-500 transition duration-150 shadow-lg shadow-green-900/50 disabled:bg-gray-500 disabled:shadow-none">
                                BUY
                            </button>
                            <button id="sell-btn" class="flex-1 py-2 rounded-lg font-bold text-lg bg-red-600 hover:bg-red-500 transition duration-150 shadow-lg shadow-red-900/50 disabled:bg-gray-500 disabled:shadow-none">
                                SELL
                            </button>
                        </div>
                        <button id="close-btn" class="w-full py-2 rounded-lg font-bold text-lg bg-amber-600 hover:bg-amber-500 transition duration-150 shadow-lg shadow-amber-900/50 disabled:bg-gray-500 disabled:shadow-none">
                            CLOSE POSITION
                        </button>
                    </div>
                    <button id="reset-btn" class="w-full py-1 text-sm rounded-lg font-medium text-gray-400 bg-gray-700 hover:bg-gray-600 transition duration-150 border border-gray-600">
                        Reset All Data
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Footer Section with Disclaimer and Trademark -->
    <footer class="mt-2 p-4 w-full text-center flex-shrink-0">
        <!-- The content wrapper inside the footer ensures the width constraint -->
        <div class="text-xs text-gray-400 space-y-2 content-wrapper mx-auto max-w-lg">
            <p class="font-bold text-amber-500">Disclaimer</p>
            <p>
                This simulator is for <b>educational purposes only</b>. It does not reflect real market conditions, and any outcomes generated should not be considered financial advice. Please consult a qualified financial professional before making real-world investment decisions.
            </p>
            <p class="pt-2 text-gray-500">
                &copy; 2025 BullBearJapan, Inc. All rights reserved.
            </p>
        </div>
    </footer>
</body>
</html>
